/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "timer.h"
#include "misc.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_exti.h"
#include "stm32f401re_syscfg.h"

void LedBuzz_Init(void);
static void Button_Init(void);
static void LedControl_SetStatus(uint8_t LED_ID, uint8_t status);
static void BuzzerControl_SetBeep(void);
void delay(uint32_t millisecond);
uint32_t CalculatorTime(uint32_t dwTimeInit, uint32_t dwTimeCurrent);
static void Interrupt_Init(void);
static void Blinkled_StatusPower(uint8_t time);
static void StatusConnected();
static void LedControl_TimPress (void);

//uint32_t time1 = 0;
//uint32_t time2 = 0;
//uint8_t status = 0; //status of button, by default = 0
//uint8_t event = 0;

#define GPIO_PIN_SET						1
#define GPIO_PIN_RESET						0
#define GPIO_PIN_LOW						0
#define GPIO_PIN_HIGH						1

#define BUZZER_GPIO_PORT					GPIOC
#define BUZZER_GPIO_PIN						GPIO_Pin_9
#define BUZZER_PIN							9
#define BUZZERControl_SetClock				RCC_AHB1Periph_GPIOC

#define LED1_RED_ID							1
#define LED1_RED_GPIO_PORT					GPIOA
#define LED1_RED_GPIO_PIN					GPIO_Pin_1
#define LED1_RED_PIN						1
#define LED1_REDControl_SetClock			RCC_AHB1Periph_GPIOA

#define LED1_GREEN_ID						0
#define LED1_GREEN_GPIO_PORT				GPIOA
#define LED1_GREEN_GPIO_PIN					GPIO_Pin_0
#define LED1_GREEN_PIN						0
#define LED1_GREENControl_SetClock			RCC_AHB1Periph_GPIOA

#define LED2_BLUE_ID						10
#define LED2_BLUE_GPIO_PORT					GPIOA
#define LED2_BLUE_GPIO_PIN					GPIO_Pin_10
#define LED2_BLUE_PIN						10
#define LED2_BLUEControl_SetClock			RCC_AHB1Periph_GPIOA

#define LED2_RED_ID							13
#define LED2_RED_GPIO_PORT					GPIOB
#define LED2_RED_GPIO_PIN					GPIO_Pin_13
#define LED2_RED_PIN						13
#define LED2_REDControl_SetClock			RCC_AHB1Periph_GPIOB

#define BUTTONB2_GPIO_PORT					GPIOB
#define BUTTONB2_GPIO_PIN					GPIO_Pin_3
#define BUTTONB2_PIN						3
#define BUTTONB2Control_SetClock			RCC_AHB1Periph_GPIOB

#define BUTTONB3_GPIO_PORT					GPIOA
#define BUTTONB3_GPIO_PIN					GPIO_Pin_4
#define BUTTONB3_PIN						4
#define BUTTONB3Control_SetClock			RCC_AHB1Periph_GPIOA

#define BUTTONB4_GPIO_PORT					GPIOB
#define BUTTONB4_GPIO_PIN					GPIO_Pin_0
#define BUTTONB4_PIN						0
#define BUTTONB4Control_SetClock			RCC_AHB1Periph_GPIOB

//System Configuration clock
#define SYSCFG_Clock						RCC_APB2Periph_SYSCFG

//event definition
#define BUTTON_RELEASED						0
#define BUTTON_PRESSED						1



typedef struct
{
	uint8_t state;
	uint32_t timePress;
	uint8_t count;
	uint32_t timeReleased;
	uint32_t firtsRelease;
	uint8_t wait;
} Button;

Button buttonB2;
Button buttonB3;
Button buttonB4;

void Button_Init1()
{
	buttonB2.count = 0;
	buttonB2.state = BUTTON_RELEASED;
	buttonB2.timePress = 0;
	buttonB2.timeReleased = 0;
	buttonB2.firtsRelease = 0;
	buttonB2.wait = 0;

	buttonB3.count = 0;
	buttonB3.state = BUTTON_RELEASED;
	buttonB3.timePress = 0;
	buttonB3.timeReleased = 0;
	buttonB3.firtsRelease = 0;
	buttonB3.wait = 0;

	buttonB4.count = 0;
	buttonB4.state = BUTTON_RELEASED;
	buttonB4.timePress = 0;
	buttonB4.timeReleased = 0;
	buttonB4.firtsRelease = 0;
	buttonB4.wait = 0;
}

//GPIO_Init for Buzzer and Led
void LedBuzz_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd(BUZZERControl_SetClock, ENABLE);

	GPIO_InitStructure.GPIO_Pin = BUZZER_GPIO_PIN;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_OType =  GPIO_OType_PP;

	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;

	//Init Buzzer

	GPIO_Init(BUZZER_GPIO_PORT, &GPIO_InitStructure);

	//Init Led1 red

	GPIO_InitStructure.GPIO_Pin = LED1_RED_GPIO_PIN;

	RCC_AHB1PeriphClockCmd(LED1_REDControl_SetClock, ENABLE);

	GPIO_Init(LED1_RED_GPIO_PORT, &GPIO_InitStructure);

	//Init Led1 GREEN

	GPIO_InitStructure.GPIO_Pin = LED1_GREEN_GPIO_PIN;

	RCC_AHB1PeriphClockCmd(LED1_GREENControl_SetClock, ENABLE);

	GPIO_Init(LED1_GREEN_GPIO_PORT, &GPIO_InitStructure);

	//Init Led2 BLUE

	GPIO_InitStructure.GPIO_Pin = LED2_BLUE_GPIO_PIN;

	RCC_AHB1PeriphClockCmd(LED2_BLUEControl_SetClock, ENABLE);

	GPIO_Init(LED2_BLUE_GPIO_PORT, &GPIO_InitStructure);

	//Init Led2 RED

	GPIO_InitStructure.GPIO_Pin = LED2_RED_GPIO_PIN;

	RCC_AHB1PeriphClockCmd(LED2_REDControl_SetClock, ENABLE);

	GPIO_Init(LED2_RED_GPIO_PORT, &GPIO_InitStructure);
}

static void Button_Init(void)	//Không gọi hàm này à em?
{
	GPIO_InitTypeDef GPIO_InitStructure;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

	//Init B2
	GPIO_InitStructure.GPIO_Pin = BUTTONB2_GPIO_PIN;
	RCC_AHB1PeriphClockCmd(BUTTONB2Control_SetClock, ENABLE);
	GPIO_Init(BUTTONB2_GPIO_PORT, &GPIO_InitStructure);

	//Init B3
	GPIO_InitStructure.GPIO_Pin = BUTTONB3_GPIO_PIN;
	RCC_AHB1PeriphClockCmd(BUTTONB3Control_SetClock, ENABLE);
	GPIO_Init(BUTTONB3_GPIO_PORT, &GPIO_InitStructure);

	//Init B4
	GPIO_InitStructure.GPIO_Pin = BUTTONB4_GPIO_PIN;
	RCC_AHB1PeriphClockCmd(BUTTONB4Control_SetClock, ENABLE);
	GPIO_Init(BUTTONB4_GPIO_PORT, &GPIO_InitStructure);
}

//Init interrupt for button
static void Interrupt_Init(void)
{
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;


	RCC_APB2PeriphClockCmd(SYSCFG_Clock, ENABLE);



	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;

	//Configure EXTI for B4
	EXTI_InitStructure.EXTI_Line = EXTI_Line0;
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource0);
	EXTI_Init(&EXTI_InitStructure);

	//Configure EXTI for B2
	EXTI_InitStructure.EXTI_Line = EXTI_Line3;
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource3);
	EXTI_Init(&EXTI_InitStructure);

	//Configure EXTI for B3
	EXTI_InitStructure.EXTI_Line = EXTI_Line4;
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource4);
	EXTI_Init(&EXTI_InitStructure);

	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

	//Configure NVIC for B2
	NVIC_InitStructure.NVIC_IRQChannel = EXTI3_IRQn;
	NVIC_Init(&NVIC_InitStructure);

	//Configure NVIC for B3
	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
	NVIC_Init(&NVIC_InitStructure);

	//Configure NVIC for B4
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
	NVIC_Init(&NVIC_InitStructure);
}

//Control LED
static void LedControl_SetStatus(uint8_t LED_ID, uint8_t status)
{
	switch(LED_ID)
	{
		case LED1_GREEN_ID:
			//Turn off LED RED
			GPIO_WriteBit(LED1_RED_GPIO_PORT, LED1_RED_GPIO_PIN, 0);
			if(status == GPIO_PIN_SET)
			{
				GPIO_WriteBit(LED1_GREEN_GPIO_PORT, LED1_GREEN_GPIO_PIN, 1);
			}
			else
			{
				GPIO_WriteBit(LED1_GREEN_GPIO_PORT, LED1_GREEN_GPIO_PIN, 0);
			}
			break;
		case LED1_RED_ID:
			//Turn off LED GREEN
			GPIO_WriteBit(LED1_GREEN_GPIO_PORT, LED1_GREEN_GPIO_PIN, 0);
			if(status == GPIO_PIN_SET)
			{
				GPIO_WriteBit(LED1_RED_GPIO_PORT, LED1_RED_GPIO_PIN, 1);
			}
			else
			{
				GPIO_WriteBit(LED1_RED_GPIO_PORT, LED1_RED_GPIO_PIN, 0);
			}
			break;
	}
}

//Control buzzer
static void BuzzerControl_SetBeep(void)
{
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 1);
	delay(50);
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 0);

	delay(50);

	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 1);
	delay(50);
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 0);

}

//Calculate time
uint32_t CalculatorTime(uint32_t dwTimeInit, uint32_t dwTimeCurrent)
{
	uint32_t dwTimeTotal;

	if(dwTimeCurrent >= dwTimeInit)
	{
		dwTimeTotal = dwTimeCurrent - dwTimeInit;
	}
	else
	{
		dwTimeTotal = 0xFFFFFFFFU + dwTimeCurrent - dwTimeInit;
	}
	return dwTimeTotal;
}

//inform that device is powered
static void Blinkled_StatusPower(uint8_t time)
{
	for(uint8_t i = 0; i < time - 1; i++)
	{
		LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
		delay(50);
		LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
		delay(50);
	}

	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
	delay(50);
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
}

//inform that device is connected
static void StatusConnected()
{
	//turn on LED
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
	//turn on BUZZER
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 1);
	delay(50);
	//turn off LED
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
	//turn off BUZZER
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 0);
	delay(50);

	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 1);
	delay(50);
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
	GPIO_WriteBit(BUZZER_GPIO_PORT, BUZZER_GPIO_PIN, 0);
	delay(50);

	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
	delay(50);
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
	delay(50);

	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
	delay(50);
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
	delay(50);

	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_SET);
	delay(50);
	LedControl_SetStatus(LED1_GREEN_ID, GPIO_PIN_RESET);
}

static void LedControl_TimPress (void)
{
	if(buttonB2.state == BUTTON_PRESSED && buttonB2.wait == 0)
	{
		if(CalculatorTime(buttonB2.timePress, GetMilSecTick()) > 500)
		{
			buttonB2.count = 0;
			GPIO_WriteBit(LED2_BLUE_GPIO_PORT, LED2_BLUE_GPIO_PIN, 1);
		}
	}
	else
	{
		if(buttonB2.wait == 0)
		{
			GPIO_WriteBit(LED2_BLUE_GPIO_PORT, LED2_BLUE_GPIO_PIN, 0);
		}
	}
	if(buttonB4.state == BUTTON_PRESSED && buttonB4.wait == 0)
	{
		if(CalculatorTime(buttonB4.timePress, GetMilSecTick()) > 500)
		{
			buttonB4.count = 0;
			GPIO_WriteBit(LED2_RED_GPIO_PORT, LED2_RED_GPIO_PIN, 1);
		}
	}
	else
	{
		if(buttonB4.wait == 0)
		{
			GPIO_WriteBit(LED2_RED_GPIO_PORT, LED2_RED_GPIO_PIN, 0);
		}

	}
}

uint8_t dem = 0;

static void LedControl_TimOutPress(void)
{
	if(buttonB2.count == 2 && buttonB2.state == BUTTON_RELEASED)
	{
//		time1 = CalculatorTime(time, GetMilSecTick());
		if(CalculatorTime(buttonB2.firtsRelease, GetMilSecTick()) == 400)
		{
			GPIO_WriteBit(LED2_BLUE_GPIO_PORT, LED2_BLUE_GPIO_PIN, 1);
			buttonB2.wait = 1;
		}
	}
	else if(buttonB2.wait == 1)
	{
		buttonB2.wait = 0;
		GPIO_WriteBit(LED2_BLUE_GPIO_PORT, LED2_BLUE_GPIO_PIN, 0);
	}
	if(buttonB4.count == 2 && buttonB4.state == BUTTON_RELEASED)
		{
//		time1 = CalculatorTime(time, GetMilSecTick());
		if(CalculatorTime(buttonB4.firtsRelease, GetMilSecTick()) == 400)
		{
			GPIO_WriteBit(LED2_RED_GPIO_PORT, LED2_RED_GPIO_PIN, 1);
			buttonB4.wait = 1;
		}
	}
	else if(buttonB4.wait == 1)
	{
		buttonB4.wait = 0;
		GPIO_WriteBit(LED2_RED_GPIO_PORT, LED2_RED_GPIO_PIN, 0);
	}
}

int main(void)
{
    LedBuzz_Init();
    Button_Init();
    Button_Init1();
    Interrupt_Init();
    Blinkled_StatusPower(4);
    TimerInit();
    while(1)
    {
		LedControl_TimPress();
    	LedControl_TimOutPress();
    }
}

void delay(uint32_t millisecond)
{
	for(uint32_t i = 0; i < millisecond; i++)
	{
		for(uint32_t j = 0; j < 5000; j++);
	}
}

//B2 interrupt handle
void EXTI3_IRQHandler(void)
{
	if(EXTI_GetFlagStatus(EXTI_Line3) == SET)
	{
		if(! GPIO_ReadInputDataBit(BUTTONB2_GPIO_PORT, BUTTONB2_GPIO_PIN))// Press button B2
		{
			buttonB2.state = BUTTON_PRESSED;
			buttonB2.timePress = GetMilSecTick();
			buttonB2.count++;
		}
		else
		{
			buttonB2.state = BUTTON_RELEASED;
			buttonB2.timeReleased = GetMilSecTick();
			if(buttonB2.count == 1)
				buttonB2.firtsRelease = buttonB2.timeReleased;
			else {
				if(buttonB2.count == 2)
				{
					if(CalculatorTime(buttonB2.firtsRelease, buttonB2.timeReleased) > 400)
					{
						buttonB2.count = 0;
					}
				}
				else
				{
					if(buttonB2.count > 2)
						buttonB2.count = 0;
				}
			}

		}
	}
	EXTI_ClearITPendingBit(EXTI_Line3);
}

//B3 interrupt handle
void EXTI4_IRQHandler(void)
{
	if(EXTI_GetFlagStatus(EXTI_Line4) == SET)
	{
		if(GPIO_ReadInputDataBit(BUTTONB3_GPIO_PORT, BUTTONB3_GPIO_PIN))
		{
			buttonB3.count++;
			buttonB3.state = BUTTON_PRESSED;
			if(buttonB3.count % 5 == 0)
			{
				StatusConnected();
			}
		}
		else
		{
			buttonB3.timeReleased = GetMilSecTick();
			buttonB3.state = BUTTON_RELEASED;
		}
	}
	EXTI_ClearITPendingBit(EXTI_Line4);
}

//B4 interrupt handle
void EXTI0_IRQHandler(void)
{
	if(EXTI_GetFlagStatus(EXTI_Line0) == SET)
	{
		if(! GPIO_ReadInputDataBit(BUTTONB4_GPIO_PORT, BUTTONB4_GPIO_PIN))// Press button B2
		{
			buttonB4.state = BUTTON_PRESSED;
			buttonB4.timePress = GetMilSecTick();
			buttonB4.count++;
		}
		else
		{
			buttonB4.state = BUTTON_RELEASED;
			buttonB4.timeReleased = GetMilSecTick();
			if(buttonB4.count == 1)
				buttonB4.firtsRelease = buttonB4.timeReleased;
			else {
				if(buttonB4.count == 2)
				{
					if(CalculatorTime(buttonB4.firtsRelease, buttonB4.timeReleased) > 400)
					{
						buttonB4.count = 0;
					}
				}
				else
				{
					if(buttonB4.count > 2)
						buttonB4.count = 0;
				}
			}
		}
	}
	EXTI_ClearITPendingBit(EXTI_Line0);
}








