/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "temhumsensor.h"
#include "Ucglib.h"
#include "timer.h"
#include "stm32f401re_i2c.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_spi.h"
#include <stdio.h>
#include <math.h>

//Macros for Init LCD
#define SPI1_CS_PORT					GPIOB
#define SPI1_CS_PIN						GPIO_Pin_6
#define SPI1_RST_PORT					GPIOC
#define SPI1_RST_PIN					GPIO_Pin_7
#define SPI1_MOSI_PORT					GPIOA
#define SPI1_MOSI_PIN					GPIO_Pin_7
#define SPI1_SCK_PORT					GPIOA
#define SPI1_SCK_PIN					GPIO_Pin_5
#define SPI1_RS_PORT					GPIOA
#define SPI1_RS_PIN						GPIO_Pin_9
#define SPI1_ENABLE_PORT				GPIOB
#define SPI1_ENABLE_PIN					GPIO_Pin_10
#define SPI1_MODE_PORT					GPIOA
#define SPI1_MODE_PIN					GPIO_Pin_8

//Macros for SPI
#define SPI_Master 						SPI1
#define SPI_Master_GPIO_Clock			RCC_AHB1Periph_GPIOA
#define SPI_Master_Clock				RCC_APB2Periph_SPI1
#define SCK_Master						SPI1_SCK_PIN
#define MOSI_Master						SPI1_MOSI_PIN
#define SPI_Master_GPIO					GPIOA
#define NSS_Master						SPI1_CS_PIN

//macros for I2C
#define I2C_MASTER_RCC					RCC_APB1Periph_I2C1
#define I2C_MASTER_INSTANCE				I2C1

#define I2C_MASTER_GPIO_RCC				RCC_AHB1Periph_GPIOB
#define I2C_MASTER_PORT					GPIOB
#define SDA_MASTER_PIN					GPIO_Pin_9
#define SCL_MASTER_PIN					GPIO_Pin_8

#define I2C_SPEED						400000

//Other macros
#define SEND							1
#define RECEIVE							0
#define SLAVE_ADDR						0x40

#define TEMPERATURE						0
#define HUMIDITY						1

void SPI_Master_GPIO_Init(void);
void SPI_Master_Init(void);
void GPIO_I2CMaster_Inits(void);
void I2CMaster_Inits(void);
static void I2C_Start(void);
static void I2C_address_direction (uint8_t SlaveAddr, uint8_t direction);
static void I2C_Transmit(uint8_t Data);
static void I2C_Stop(void);
uint8_t I2C_receive_ack(void);
uint8_t I2C_receive_nack(void);
void delay(uint32_t millisecond);
float CalculateTemp(uint16_t data);
float CalculateHumi(uint16_t data);
float ReadHumidity(void);
float ReadTemperature(void);
void processGetValueSensor(void);
float TemHumSensor_readRegister(uint8_t slave_addr, uint8_t cmd_id, uint8_t tempOrhumi);
uint32_t CalculatorTime(uint32_t dwTimeInit, uint32_t dwTimeCurrent);
void InitSensor(void);

typedef struct
{
	float humi;
	float temp;
}Sensor;

GPIO_InitTypeDef 	GPIO_InitStructure;
SPI_InitTypeDef		SPI_InitStructure;

//Init for CS, SS, MOSI
void SPI_Master_GPIO_Init(void)
{
	//Enable cloxk
	RCC_AHB1PeriphClockCmd(SPI_Master_GPIO_Clock, ENABLE);

//	//Init GPIO use for SPI
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

//	GPIO_InitStructure.GPIO_Pin = SCK_Master | MOSI_Master | NSS_Master | SPI1_RS_PIN | SPI1_RST_PIN;
	GPIO_InitStructure.GPIO_Pin =  SPI1_CS_PIN | SPI1_RST_PIN | SPI1_MOSI_PIN |
			SPI1_SCK_PIN | SPI1_RS_PIN | SPI1_ENABLE_PIN | SPI1_MODE_PIN;
	GPIO_Init(SPI_Master_GPIO, &GPIO_InitStructure);

	//Connect SPI1 pins to SPI Alternate function
//	GPIO_PinAFConfig(SPI_Master_GPIO, GPIO_PinSource5, GPIO_AF_SPI1);
//	GPIO_PinAFConfig(SPI_Master_GPIO, GPIO_PinSource7, GPIO_AF_SPI1);
//	GPIO_PinAFConfig(SPI_Master_GPIO, GPIO_PinSource6, GPIO_AF_SPI1);

//	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
//	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
//	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
//
//	GPIO_InitStructure.GPIO_Pin = NSS_Master;
//
//	GPIO_Init(SPI_Master_GPIO, &GPIO_InitStructure);

}

//Init SPI1 peripheral
void SPI_Master_Init(void)
{
	//Enable peripheral clock
	RCC_APB1PeriphClockCmd(SPI_Master_Clock, ENABLE);

	//Full duplex mode
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;

	//Master mode
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;

	//8 bit transmited
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;

	//clock is low when idle
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;

	//Data sampled at first edge
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;

	//Set NSS as software
//	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;

	//SPI prescaler/4
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;

	//Data transmitted LSB first
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;

	SPI_Init(SPI_Master, &SPI_InitStructure);
	//Enable SPI2
	SPI_Cmd(SPI_Master, ENABLE);
}


//I2C1_SDA: PB9
//I2C1_SCL:	PB8
//Init pins for I2C1
void GPIO_I2CMaster_Inits(void)
{
	GPIO_InitTypeDef	GPIO_InitStruct;
	//Enable clock for I2C1
	RCC_APB1PeriphClockCmd(I2C_MASTER_RCC, ENABLE);

	//Enable clock for GPIOB
	RCC_AHB1PeriphClockCmd(I2C_MASTER_GPIO_RCC, ENABLE);

	//Alternate function mode
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_OType = GPIO_OType_OD;
	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;

	GPIO_InitStruct.GPIO_Pin = SCL_MASTER_PIN;
	GPIO_Init(I2C_MASTER_PORT, &GPIO_InitStruct);

	GPIO_InitStruct.GPIO_Pin = SDA_MASTER_PIN;
	GPIO_Init(GPIOB, &GPIO_InitStruct);

	//config SCL and SDA for Alternate function mode
	GPIO_PinAFConfig(I2C_MASTER_PORT, GPIO_PinSource8, GPIO_AF_I2C1);
	GPIO_PinAFConfig(I2C_MASTER_PORT, GPIO_PinSource9, GPIO_AF_I2C1);
}

//Init I2C1 peripheral
void I2CMaster_Inits(void)
{
	I2C_InitTypeDef		I2C_InitStruct;
	I2C_InitStruct.I2C_ClockSpeed = I2C_SPEED;//FAST mode
	I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;
	I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;
	I2C_InitStruct.I2C_OwnAddress1 = 0x00;
	I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;
	//7 bits address
	I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;

	//Init I2C1 peripheral
	I2C_Init(I2C_MASTER_INSTANCE, &I2C_InitStruct);

	//Enable I2C1 peripheral
	I2C_Cmd(I2C_MASTER_INSTANCE, ENABLE);
}

//I2C_START condition
static void I2C_Start(void)
{
	//Wait until I2Cx is not busy
	while(I2C_GetFlagStatus(I2C_MASTER_INSTANCE, I2C_FLAG_BUSY));//??
    //Generate Start condition
	I2C_GenerateSTART(I2C_MASTER_INSTANCE, ENABLE);

	while(! I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_MODE_SELECT));


}

//I2C master send Address for Slave and r/w bit
//direction: SEND or RECEIVE
static void I2C_address_direction (uint8_t SlaveAddr, uint8_t direction)
{
	//left shift address for 1 bit r/w
	SlaveAddr = SlaveAddr << 1;
	if(direction == SEND)
	{
		//inform that master wants to write to slave
		I2C_Send7bitAddress(I2C_MASTER_INSTANCE, SlaveAddr, I2C_Direction_Transmitter);
		while(! I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
	}
	else if (direction == RECEIVE)
	{
		//inform that master wants to read data from slave
		I2C_Send7bitAddress(I2C_MASTER_INSTANCE, SlaveAddr, I2C_Direction_Receiver);
		while(! I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
	}

}

//Send data to slave
static void I2C_Transmit(uint8_t Data)
{
	I2C_SendData(I2C_MASTER_INSTANCE, Data);

	while(! I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
}

//Generate stop condition
static void I2C_Stop(void)
{
	//Generate Start condition
	I2C_GenerateSTOP(I2C_MASTER_INSTANCE, ENABLE);

}

//receive data accomplish nack
uint8_t I2C_receive_nack(void)
{
	uint8_t data_receive = 0;

	I2C_AcknowledgeConfig(I2C_MASTER_INSTANCE, DISABLE);

	//Wait until I2Cx is not busy
//	while(I2C_GetFlagStatus(I2C_MASTER_INSTANCE, I2C_FLAG_BUSY));
	while(! I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_BYTE_RECEIVED));
	data_receive = I2C_ReceiveData(I2C_MASTER_INSTANCE);

	return data_receive;
}

//receive data accomplish ack
uint8_t I2C_receive_ack(void)
{
	uint8_t data_receive = 0;

	I2C_AcknowledgeConfig(I2C_MASTER_INSTANCE, ENABLE);

	//Wait until I2Cx is not busy
	while(! I2C_CheckEvent(I2C_MASTER_INSTANCE, I2C_EVENT_MASTER_BYTE_RECEIVED));

	data_receive = I2C_ReceiveData(I2C_MASTER_INSTANCE);

	return data_receive;
}

//Formula for calculating temperature
float CalculateTemp(uint16_t data)
{
	float result = (175.2*data)/65536-46.85;
	return result;
}

//Formula for calculating humidity
float CalculateHumi(uint16_t data)
{
	float result = 125.0*data/65536-6;
	return result;
}

//Read temperature or humidity from sensor
//slave address: 0x40
//cmi_id: 0xE3: get temperature,    0xE5: get humidity
//temOrhumi: TEMPERATURE or HUMIDITY
float TemHumSensor_readRegister(uint8_t slave_addr, uint8_t cmd_id, uint8_t tempOrhumi)//0xE3: get tempereature
{
	//data are got from sensor
	uint16_t data = 0;

	//result calculate from data
	float result = 0;

	//Genrate start condition
	I2C_Start();

	//send 7 bits address to slave and 1 bit write
	I2C_address_direction(slave_addr, SEND);

	//send cmd_id to slave
	I2C_Transmit(cmd_id);

	//Repeated start
	I2C_Stop();
	I2C_Start();

	//Send 7 bits address to slave and 1 bit read
	I2C_address_direction(slave_addr, RECEIVE);

	//Get MS byte
	data = (uint16_t)I2C_receive_ack();
	//Get LS byte
	data = (data << 8 ) | (uint16_t)I2C_receive_nack();

	//Indentify whether get humidity or temperature
	switch(tempOrhumi)
	{
		case TEMPERATURE:
			result = CalculateTemp(data);
			break;
		case HUMIDITY:
			result = CalculateHumi(data);
			break;
		default:
			break;
	}

	//Generate stop condition
	I2C_Stop();

	return result;
}

//Read Temperature
float ReadTemperature(void)
{
	return TemHumSensor_readRegister(0x40, 0xE3, TEMPERATURE);
}

//Read Humidity
float ReadHumidity(void)
{
	return TemHumSensor_readRegister(0x40, 0xE5, HUMIDITY);
}

//Calculate time
uint32_t CalculatorTime(uint32_t dwTimeInit, uint32_t dwTimeCurrent)
{
	uint32_t dwTimeTotal;

	if(dwTimeCurrent >= dwTimeInit)
	{
		dwTimeTotal = dwTimeCurrent - dwTimeInit;
	}
	else
	{
		dwTimeTotal = 0xFFFFFFFFU + dwTimeCurrent - dwTimeInit;
	}
	return dwTimeTotal;
}

static ucg_t ucg;
uint32_t time_initial = 0;

//Buffer to convert float to string for LCD display
char bufTemp[5];
char bufHumi[5];

//including sensor information
Sensor sensorBefore;
Sensor sensorAfter;

//Init for Sensor
void InitSensor(void)
{
	sensorBefore.humi = 0;
	sensorBefore.temp = 0;

	sensorAfter.humi = 0;
	sensorAfter.temp = 0;
}

//Get sensor value every 5s period
//Change temperature display if the difference is more than 0.5oC
//Change humidity display if the difference is more than 1%
void processGetValueSensor(void)
{
	if(CalculatorTime(time_initial, GetMilSecTick()) >= 5000)//After 5s
	{
		//read Sensor data
		sensorAfter.humi = ReadHumidity();
		sensorAfter.temp = ReadTemperature();

		//humi max = 100%
		if(sensorAfter.humi > 100)
			sensorAfter.humi = 100;
		//humi min = 0%
		else if (sensorAfter.humi < 0) {
			sensorAfter.humi = 0;
		}

		//temperature max = 100 oC
//		if(sensorAfter.temp > 100)
//			sensorAfter.temp = 100;

		//Get the diff value of temp and humi
		float absTemp = fabsf(sensorAfter.temp - sensorBefore.temp);
		float absHumi = fabsf(sensorAfter.humi - sensorBefore.humi);

		//if humi diff > 1% than display on LCD
		if(absHumi > 1)
		{
			sprintf (bufHumi, "%.2f", sensorAfter.humi);
			ucg_DrawString (&ucg, 65, 30, 0, bufHumi);
			//Update humi
			sensorBefore.humi = sensorAfter.humi;
		}
		//if temp diff > 0.5oC than display on LCD
		if(absTemp > 0.5)
		{
			sprintf (bufTemp, "%.2f", sensorAfter.temp);
			ucg_DrawString (&ucg, 55, 50, 0, bufTemp);
			//Update temp
			sensorBefore.temp = sensorAfter.temp;
		}
		//Update time_initial
		time_initial = GetMilSecTick();
	}
}

int main(void)
{
	//Init sensor value
	InitSensor();

	//HSE clock 84 MHz
	SystemCoreClockUpdate();

	//Init timer
	TimerInit();

	//Init I2C
	GPIO_I2CMaster_Inits();
	I2CMaster_Inits();

	//Init LCD
	Ucglib4WireSWSPI_begin(&ucg, UCG_FONT_MODE_SOLID);

	SPI_Master_GPIO_Init();
	SPI_Master_Init();

	//Display some required parts
	ucg_ClearScreen(&ucg);

	ucg_SetFont(&ucg, ucg_font_ncenR12_hr);

	ucg_SetColor(&ucg, 0, 255, 255, 255);

	ucg_SetColor(&ucg, 1, 0, 0, 0);

	ucg_SetRotate180(&ucg);

	ucg_DrawString (&ucg, 5, 30, 0, "Humid:");
	ucg_DrawString (&ucg, 105, 30, 0, "%");
	ucg_DrawString (&ucg, 5, 50, 0, "Temp:");
	ucg_DrawString (&ucg, 100, 50, 0, "0C");

	//Init time_initial
	time_initial = GetMilSecTick();
	while(1)
	{
		processTimerScheduler();
		//Get sensor values
		processGetValueSensor();
	}
}
//delay
void delay(uint32_t millisecond)
{
	for(uint32_t i = 0; i < millisecond; i++)
	{
		for(uint32_t j = 0; j < 5000; j++);
	}
}










